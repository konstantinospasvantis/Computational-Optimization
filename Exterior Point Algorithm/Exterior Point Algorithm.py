# -*- coding: utf-8 -*-
"""Exterior Point Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_PysXvl3jMoVmNAmf3p7DbhQ7C7Phr3c
"""

import numpy as np
np.set_printoptions(threshold=np.inf)

f=open('sdata1_200x200.mps' ,'r')

s=f.readline()
s=f.readline()
s=f.readline()
#ROWS ta vazoyme se dict
eq_type=dict()
m=0
while s[:7] != 'COLUMNS':
  if s[1:3].strip() in ['E','L','G']:
    rowlabel=s[4:12].strip()
    eq_type[rowlabel]=s[1:3].strip()
    m=m+1
  elif s[1:3].strip() == 'N' :
    name_obj=s[4:12].strip()
  s=f.readline()


#EXOUME VALEI TIS GRAMMES ME TA E L G SE ENA DICT
s=f.readline()
arith={list(eq_type.keys())[i]:list(range(0,m+1))[i] for i in range(m)}
A=np.zeros(m)
a=np.zeros(m)
n=0
dict_obj=dict()
metav={s[4:12].strip():0}


while s[:3]!= 'RHS' :
    if s[4:13].strip() in metav :
        if s[14:22].strip() in arith :
            a[arith[s[14:22].strip()]]=float(s[24:36].strip())
            if s[39:47].strip() in arith :
                a[arith[s[39:47].strip()]]=float(s[49:61].strip())
            elif s[39:47].strip() == name_obj :
                dict_obj[s[4:12].strip()]=float(s[49:61].strip())
            elif s[39:47].strip()=='':
                pass
        elif s[14:22].strip() == name_obj :
            dict_obj[s[4:12].strip()]=float(s[24:36].strip())
            if s[39:47].strip() in arith :
                a[arith[s[39:47].strip()]]=float(s[49:61].strip())
            elif s[39:47].strip() == '' :
                pass


    elif s[4:13].strip() not in metav :
        n=n+1
        A=np.vstack([A,a])
        a=np.zeros(m)
        metav[s[4:12].strip()]=n
        if s[14:22].strip() in arith :
            a[arith[s[14:22].strip()]]=float(s[24:36].strip())
            if s[39:47].strip() in arith :
                a[arith[s[39:47].strip()]]=float(s[49:61].strip())
            elif s[39:47].strip() == name_obj :
                dict_obj[s[4:12].strip()]=float(s[49:61].strip())
            elif s[39:47].strip()=='':
                pass
        elif s[14:22].strip() == name_obj :
            dict_obj[s[4:12].strip()]=float(s[24:38].strip())
            if s[39:49].strip() in arith :
                a[arith[s[39:49].strip()]]=float(s[49:61].strip())
            elif s[39:49].strip() == '' :
                pass

    s=f.readline()

n=n+1
A=np.vstack([A,a])
A=np.delete(A,0,axis=0)
A=np.transpose(A)

#Exw teleiwsei me ton A , exw vrei diastaseis

s=f.readline()
b=np.zeros(m)
while s[:6] != 'ENDATA' :
    if s[14:23].strip() in arith :
        b[arith[s[14:22].strip()]]=float(s[24:36].strip())
        if s[39:47].strip() in arith :
            b[arith[s[39:47].strip()]]=float(s[49:61])
        elif s[39:47].strip() == '' :
            pass
    s=f.readline()

b=np.asarray(b)
c=np.zeros(n)
for i in dict_obj :
    c[metav[i]]=dict_obj[i]

Eqin=np.zeros(m)
for i in arith :
    if eq_type[i] == 'E' :
        Eqin[arith[i]]= 0
    elif eq_type[i] == 'G' :
        Eqin[arith[i]] = 1
    elif eq_type[i] == 'L' :
        Eqin[arith[i]] = -1
Eqin = np.asarray(Eqin)

c=np.asarray(c)
c=np.transpose(c)
f.close()

"""# MAiN SCRIPT"""

import time
start=time.process_time()
m=A.shape[0]
n=A.shape[1]
#Creating an empty A_b matrix so i can append the 
A_b=np.empty((m,0))
a=np.zeros((m,1))
###
#Creating the A_b matrix and then appending it to A
for i in range(m):
  a=np.zeros((m,1))
  if Eqin[i]==-1:
    a[i]=1
    A_b=np.append(A_b,a,1)
  elif Eqin[i]==0:
    pass
  else:
    a[i]=-1
    A_b=np.append(A_b,a,1)
A=np.append(A,A_b,1)                                    #Appending in A, c
c=np.append(c,np.zeros(A.shape[1]-n))
# We have found the new A, A_b, c
Set_of_all_indices=set(i for i in range(A.shape[1]))   #Finding the sets B, N s
N=set(i for i in range(n))
B=Set_of_all_indices-N
N=list(N)                                              #Converting the sets B, N into a list
B=list(B)
InvA_b=np.linalg.inv(A_b)                              #Inverse of matrix A_b
x_b=np.dot(InvA_b,b)                                   #Vector x_b
c_b=c[B]                                               #Vector c_b
wT=np.dot(c_b,InvA_b)                                  #Vector w^T
S_n=c[N]-np.dot(wT,A[:,N])                             #Vector S_n
P=set(N[i] for i in range(len(S_n)) if S_n[i]<0)       #Finding sets P, Q
Q=set(N)-P                                             
P=list(P)                                              #Converting the sets P, Q into a list 
Q=list(Q)
lam=np.ones(len(P))
s_0=np.inner(lam,S_n[P])   
print(s_0)                                             #Finding s_0
d_b=np.zeros(m)                                        #Finding d_b
for i in P:
  d_b=d_b+np.dot(InvA_b,A[:,i])
d_b=np.dot(-1,d_b)
#Finding 'a', and then find the variable that leaves B, with the help of dictionaries
a_dict=dict()                                         
for i in range(len(d_b)):
  if d_b[i]<0:
    a_dict[i]=x_b[i]/(-d_b[i])
r=min(a_dict,key=a_dict.get)                           
ejerxomeni_metavliti=B[r]     
#Find Hrp and Hrq Vectors                         
Hrp=np.dot(InvA_b[r,:],A[:,P])                        
Hrq=np.dot(InvA_b[r,:],A[:,Q])
#Find theta1, theta2 to continue                        
S_p, S_q=S_n[P], S_n[Q]
theta1_dict=dict()                                  
for i in range(len(Hrp)):
  if Hrp[i]>0:
    theta1_dict[i]=-S_p[i]/Hrp[i]
t1=min(theta1_dict,key=theta1_dict.get)
theta1=theta1_dict[t1]

theta2=np.infty
theta2_dict=dict()                                    
for i in range(len(Hrq)):
  if Hrq[i]<0:
    theta2_dict[i]=-S_q[i]/Hrq[i]
if len(theta2_dict)!=0:
  t2=min(theta2_dict,key=theta2_dict.get)
  theta2=theta2_dict[t2]

#Comparing theta1 theta2
if theta1<theta2:
  l=P[t1]
else:
  l=Q[t2]
#Making use of Eta matrix (When i tried to implement the algorithm with d_b=(A_b)^-1*d_b, it gave me errors)
Eta=np.identity(m)  
stili_allagis=np.dot(InvA_b,A[:,l])
Eta[:,r]=stili_allagis
d_b=np.dot(np.linalg.inv(Eta),d_b)
if (l in P):
  d_b[r]+=1
InvA_b=np.dot(np.linalg.inv(Eta),InvA_b)
if theta1<theta2:
  P.remove(l)
  Q.append(ejerxomeni_metavliti)
else:
   Q[t2]=ejerxomeni_metavliti
B[r]=l
N=P+Q
#Creating an boolean variable so that we can escape the iterations
Bool_var=True
metritis_i=0
while Bool_var:
  #Calculating again the vectors that we need
  x_b=np.dot(InvA_b,b)
  c_b=c[B]  
  wT=np.dot(c_b,InvA_b) 
  S_n=c[N]-np.dot(wT,A[:,N]) 
  lam=np.ones(len(P))
  s_0=0
  for i in range(len(P)):
    s_0+=lam[i]*S_n[i]
  print('s_0= ' + str(s_0))  
  if s_0==0 or len(P)==0 or all(x>0 for x in d_b):
    Bool_var=False
    break
  a_dict=dict()                                         
  for i in range(len(d_b)):
    if d_b[i]<0:
      a_dict[i]=x_b[i]/(-d_b[i])
  r=min(a_dict,key=a_dict.get)                           
  ejerxomeni_metavliti=B[r]     
  #Find Hrp and Hrq Vectors                         
  Hrp=np.dot(InvA_b[r,:],A[:,P])                        
  Hrq=np.dot(InvA_b[r,:],A[:,Q])
  #Find theta1, theta2
  theta1=np.infty
  theta1_dict=dict()     
  if len(Hrp)!=0:
    for i in range(len(Hrp)):
      if Hrp[i]>0:
        theta1_dict[i]=-S_n[i]/Hrp[i]
  if len(theta1_dict)!=0:
    t1=min(theta1_dict,key=theta1_dict.get)
    theta1=theta1_dict[t1]
  theta2=np.infty
  theta2_dict=dict()           
  if len(Hrq)!=0:
    for i in range(len(Hrq)):
      if Hrq[i]<0:
        theta2_dict[i]=-S_n[i+len(P)]/Hrq[i]
  if len(theta2_dict)!=0:
    t2=min(theta2_dict,key=theta2_dict.get)
    theta2=theta2_dict[t2]
  #Comparing theta1 theta2
  if theta1<theta2:
    l=P[t1]
  else:
    l=Q[t2]
  #Making use of Eta matrix again
  Eta=np.identity(m)  
  stili_allagis=np.dot(InvA_b,A[:,l])
  Eta[:,r]=stili_allagis
  d_b=np.dot(np.linalg.inv(Eta),d_b)
  if (l in P):
    d_b[r]+=1
  InvA_b=np.dot(np.linalg.inv(Eta),InvA_b)
  if theta1<theta2:
    P.remove(l)
    Q.append(ejerxomeni_metavliti)
  else:
    Q[t2]=ejerxomeni_metavliti
  B[r]=l
  N=P+Q
  metritis_i+=1
  print('Number of iterations so far = ' +str(metritis_i))
end=time.process_time()
res = end-start
print('CPU Execution time: ','{:.4f}'.format(res), 'seconds')
opt_value=0
for i in range(len(B)):
  opt_value+=x_b[i]*c[B[i]]
print('The optimal value is achieved with X_b= '+str(x_b) + 'and B =' + str(B))
print('The optimal value for this problem is: {:.4f}'.format(opt_value))
print('CPU Execution time: ','{:.4f}'.format(res), 'seconds')
print('Number of total iterations  = ' +str(metritis_i))